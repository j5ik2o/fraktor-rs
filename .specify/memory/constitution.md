<!--
Sync Impact Report
Version change: 1.7.0 → 1.8.0
Modified principles:
- 実装規約と構造制約：ライフタイム指向とアロケーション最小化の指針を追記
Added sections:
- VII. ライフタイム優先設計
Removed sections:
- なし
Templates requiring updates:
- ✅ .specify/templates/plan-template.md
- ✅ .specify/templates/spec-template.md
- ✅ .specify/templates/tasks-template.md
Follow-up TODOs:
- なし
-->

# fraktor-rs Constitution

## Core Principles

### I. no_stdコアの維持
- `modules/*-core` クレートは常に `#![no_std]` でビルド可能でなければならない。
- `std` への依存は `cfg(test)` またはホスト専用クレートに限定し、ランタイム本体に `#[cfg(feature = "std")]` を導入してはならない。
- `modules/*-core` では `tokio` や `embassy` を含むランタイムクレートを依存に追加してはならない。`tokio` 依存は `*-std`、`embassy` 依存は `*-embedded` クレートに隔離する。
- `std` が必要な機能はアダプタ層を別クレートで提供し、境界を明確化すること。
理由: 組込みターゲットでの動作保証と決定論的挙動を維持するため。

### II. テスト完全性とCI厳守
- 各ユーザーストーリーは失敗するテストから実装を開始し、完了時に `./scripts/ci-check.sh all` をグリーンに保つ。
- テストのコメントアウト・`#[ignore]` 化・削除は禁止する。
- テスト結果は計画/タスク文書に記録し、失敗時は原因と対策を明示する。
理由: 品質を定量的に担保し、CIで早期に退行を検出するため。

### III. リファレンス整合設計
- protoactor-go と Apache Pekko の該当実装を調査し、設計意図を Rust イディオムへ変換して取り込む。
- 参考実装との差分を文書化し、意図的な乖離には根拠とフォローアップを提示する。
- 参照結果は spec/plan/tasks に反映し、変更履歴を追跡可能にする。
理由: 既存の成熟したアクターランタイムの知見を再利用し、設計の一貫性を守るため。

### IV. モジュール構造と型隔離
- 2018 モジュールシステムを採用し、`mod.rs` を使用しない。
- 1 ファイルには 1 つの構造体または 1 つの trait のみを定義し、単体テストは `target/tests.rs` 形式で分離する。
- 内部では FQCN による `use` を基本とし、`prelude` は外部公開向けに限定する。
- `docs/guides/module_wiring.md` の規約とカスタム lint（module-wiring, type-per-file 等）を満たすこと。
理由: モジュール可読性とビルド規律を保ち、tooling による自動検証を成立させるため。

### V. 攻めの設計進化
- まだプレリリース段階であるため、最適な設計を優先し破壊的変更を恐れない。
- 破壊的変更は spec/plan/tasks で移行手順と影響範囲を先に定義し、レビュアブルな形で提示する。
- 変更後は関連ドキュメントとテンプレートの更新を即座に実施する。
理由: フィードバックループを短縮し、将来の負債を抑制するため。

### VI. 帰納的一貫性駆動の設計
- 新規実装や改善に着手する前に、同等の責務を持つ既存コードを必ず調査し、採用されている設計パターン・抽象化・命名を写経レベルで理解する。
- 既存実装の大半が特定の手法（例: トレイトオブジェクト）で統一されている場合は、原則として同じ手法を継続し、意図的に外れる場合は spec/plan/tasks に理由と影響を文書化する。
- 調査結果と参照元のパスを記録に残し、帰納的に得たルールをレビューで提示する。
理由: コードベース全体の設計一貫性を保持し、学習コストと運用負債を抑制するため。

### VII. ライフタイム優先設計
- API は所有権移動よりも借用と明示的ライフタイムによる表現を優先し、スタック常駐のデータ再利用を基本とする。
- `alloc` によるヒープ確保は不可避な箇所に限定し、バッファ再利用やオブジェクトプールを用いて確保回数と断片化を抑制する。アロケーションが発生する箇所は spec/plan/tasks に根拠と測定結果を記録する。
- メッセージやコンテキストは `AnyMessage` などのコンテナを用いる場合でもコピーを最小化し、ライフタイム整合性をコードレビューで検証可能な API とする。
- ライフタイムや所有権の境界が複雑になる場合は安全性の設計根拠を事前に文書化し、レビューで検証を受ける。
- 同じ型や trait を異なる責務に使い回すことを禁じ、必要に応じて専用型（例: ActorError と SendError）を定義し、責務の境界を明確にする。
理由: アロケーション起因の断片化やスループット低下を防ぎ、組込み環境での決定論的性能を維持するため。

## 実装規約と構造制約

- `modules/actor-core` と `modules/utils-core` は `alloc` 系ライブラリを活用しつつ `#![no_std]` を徹底し、`panic-halt` などの組込み向け設定を維持する。
- `tokio` や `embassy` のようなランタイム依存は `modules/*-core` から排除し、対応する `*-std` / `*-embedded` クレートに限定する。
- テストやベンチマークで `std` を利用する場合でも `cfg(test)` や専用クレート内に封じ込める。
- 単体テストは対象モジュールと同階層の `tests.rs` にまとめ、共通ヘルパーは別モジュールに分離する。
- rustdoc（`///`, `//!`）は英語で記述し、それ以外のコメント・ドキュメントは日本語で記述する。
- FQCN による `use` を基本とし、再エクスポートは末端モジュールの直属親に限定する。
- `lints/` 配下のカスタム lint は `lints/*/README.md` に明文化されたルールを参照し、作業前後で `makers ci-check -- dylint` を実行して逸脱を検知する。AI や CI が自動修正を試みる前に必ず内容を更新・確認する。
- `alloc::sync::Arc` や `spin::Mutex` 等の直接利用は禁止し、共有参照やロックは必ず `modules/utils-core` の `Shared`/`ArcShared`/`RcShared` と `AsyncMutexLike`/`SyncMutexLike` 抽象を介して差し替え可能に実装する。`no_std` では `SpinAsyncMutex`/`SpinSyncMutex` をデフォルトとし、プラットフォーム固有実装を導入する場合は同抽象を拡張する。
- `Shared` 系の型や変数名には `_shared` / `Shared` サフィックスを用い、`Handle` プレフィックス/サフィックスでの命名は禁止する。共有参照は組込み負荷を考慮して必要最小限とし、代替手段がある場合は `Shared` を避ける。`Driver` や `Facade` といった実装都合を想起させるサフィックスの利用も禁止する。
- ランタイム API と内部データ構造は借用を中心としたライフタイム設計を採用し、ヒープ確保が必要な場合は用途・頻度・再利用戦略を仕様とタスクで共有する。スタックや静的領域で表現可能なデータに対してはアロケータを経由しない。
- 公開 API の型・trait・メソッドには `Typed` といった歴史的命名を含めず、`ActorRef<M>` のように静的型付けを前提とした名称を採用する。内部向けの `Any` ベース構造には `Internal` 等で明確に区別する。
- 循環参照を発生させない設計を優先し、`Weak` 連鎖に依存した複雑な API を導入しない。必要な場合は `MapSystemFn` など関数型抽象で依存関係を解消し、設計レビューで循環構造の有無を検証する。
- 組込みターゲットを考慮し、主要コンポーネントはプラガブルな差し替え点（抽象化と実装切替）を備える。ただしトレイトオブジェクトの多用は避け、可能な限り静的バインディングとジェネリックで解決する。トレイトオブジェクトを使用する場合は性能とコードサイズへの影響を分析し、記録する。
- 通信・シリアライズ・トランスポート層は特定実装（例: protobuf, TCP）に固定せず、抽象インターフェイスを介して差し替え可能にする。`no_std` でも利用可能なフォーマット／トランスポートを優先し、組込みで非対応な技術（protobuf 等）を前提にしない。

## 開発フローとレビュー手順

- 新規機能や破壊的変更は OpenSpec ワークフローで plan/spec/tasks を整備し、憲章チェックを通過してから実装を開始する。
- コード調査・編集には Serena MCP ツールを使用し、取得した知見を記録として残す。
- 実装前に関連モジュールや同種機能のコードを読み込み、支配的な設計パターンとの差分を plan/spec/tasks に記録する。
- すべての作業は `./scripts/ci-check.sh all` と `makers ci-check -- dylint` の双方を完了条件とし、結果ログをレビューに添付する。
- 重大な差分は protoactor-go / Apache Pekko の比較結果とともにレビューに提示する。
- 完了したユーザーストーリーごとにテスト結果とドキュメント更新を報告し、段階的なデモ/デプロイを可能にする。

## Governance

- この憲章は fraktor-rs の開発規範の唯一の出典であり、他ドキュメントより優先される。
- 改定は OpenSpec プロポーザルの承認を前提とし、変更理由・影響分析・テンプレート更新計画を含めなければならない。
- バージョニングは SemVer に従う: 原則の差し替えや削除は MAJOR、原則追加や大幅な運用指針拡張は MINOR、表現調整や軽微な補足は PATCH を増分する。
- すべての PR は憲章遵守チェックリストをレビューコメントに添付し、CI 結果とテスト稼働ログを含める。
- 四半期ごとにメンテナが遵守状況を棚卸しし、逸脱があれば是正計画と期日を記録する。

**Version**: 1.8.0 | **Ratified**: 2025-10-28 | **Last Amended**: 2025-10-29
