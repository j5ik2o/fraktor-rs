---
name: Rust Error Handling
description: Rustのエラーハンドリング方針に関する依頼で使う。回復可能性を基準にResultとpanicを使い分け、境界で適切にエラー型を設計・変換する。
---

# Rust Error Handling

Rustにおけるエラーハンドリングの基本原則と実装ガイドラインをまとめたスキル。

## 基本原則

エラーハンドリングは「回復可能性」を基準に設計する。  
回復可能なら `Result<T, E>`、回復不能なら `panic!` 系で処理する。

## 回復可能なエラー

実行継続が可能なエラーは `Result<T, E>` を返す。

### 代表例

- ドメインモデルのビジネスルール違反（バリデーション、在庫不足、権限不足）
- 外部データアクセスの一時的エラー（DB接続、外部APIの予期された失敗、楽観ロック競合）
- ユースケース層のワークフロー不整合（状態遷移の失敗など）

### 設計の指針

- エラー型は `enum` で表現し、文字列だけで済ませない
- 低レイヤのエラーは上位境界で意味のある型に変換する
- 根本原因がある場合は `source` を保持して失われないようにする

## 回復不能・致命的状況

回復不能な状況は `panic!` / `unreachable!()` を用いる。  
ただし使用は最小限にし、誤用の温床になる箇所では避ける。

### 代表例

- **引数としてありえない状況**: `panic!`（プログラムの契約違反）
- **状態としてありえない状況**: `panic!`
- **到達不能コード**: `unreachable!()`

## 設計時の確認事項

1. **このエラーは回復可能か？**  
   - はい → `Result<T, E>` を使う  
   - いいえ → `panic!` / `unreachable!()`
2. **エラーの性質は何か？**  
   - 入力契約違反か  
   - 内部状態の破綻か  
   - 到達不能な分岐か
3. **失敗時に期待される動作は？**  
   - 代替パス  
   - リトライ  
   - ユーザーへの通知  
   - ログ記録

## 運用上の注意

- `unwrap()` / `expect()` はテストや明確な不変条件の確認に限定する  
- `panic` は回復不能な契約違反・不変条件違反のみに限定する  
- 不要な `panic` が混入していないかレビューで確認する  

