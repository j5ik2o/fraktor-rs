# レビューポリシー

全レビュアーが共有する判断基準と行動原則を定義する。

## 原則

| 原則 | 基準 |
|------|------|
| 即座修正 | 軽微でも「次のタスク」にしない。今修正できる問題は今修正させる |
| 曖昧さ排除 | 「もう少し整理して」等の曖昧な指摘は禁止。ファイル・行・修正案を具体的に示す |
| ファクトチェック | 推測ではなく実コードを確認してから指摘する |
| 実践的修正案 | 理想論ではなく実装可能な対策を提示する |
| ボーイスカウト | 変更したファイルに問題があれば、タスクスコープ内で改善させる |

## スコープ判定

| 状況 | 判定 | 対応 |
|------|------|------|
| 今回の変更で導入された問題 | ブロッキング | REJECT |
| 今回の変更により未使用になったコード（引数、import、変数、関数） | ブロッキング | REJECT（変更起因の問題） |
| 変更ファイル内の既存問題 | ブロッキング | REJECT（ボーイスカウトルール） |
| 変更モジュール内の構造的問題 | ブロッキング | スコープ内なら REJECT |
| 変更外ファイルの問題 | 非ブロッキング | 記録のみ（参考情報） |
| タスクスコープを大きく逸脱するリファクタリング | 非ブロッキング | 提案として記載 |

## 判定基準

### REJECT（差し戻し）

以下のいずれかに該当する場合、例外なく REJECT する。

- テストがない新しい振る舞い
- バグ修正にリグレッションテストがない
- `any` 型の使用
- フォールバック値の乱用（`?? 'unknown'`）
- 説明コメント（What/How のコメント）
- 未使用コード（「念のため」のコード）
- オブジェクト/配列の直接変更
- エラーの握りつぶし（空の catch）
- TODO コメント（Issue化されていないもの）
- 本質的に同じロジックの重複（DRY違反）
- 同じことをするメソッドの増殖（構成の違いで吸収すべき）
- 特定実装の汎用層への漏洩（汎用層に特定実装のインポート・分岐がある）
- 内部実装のパブリック API エクスポート（インフラ層の関数・内部クラスが公開されている）
- リファクタリングで置き換えられた旧コード・旧エクスポートの残存
- 関連フィールドのクロスバリデーション欠如（意味的に結合した設定値の不変条件が未検証）

### Warning（警告）

ブロッキングではないが改善を推奨する。

- エッジケース・境界値のテスト不足
- テストが実装の詳細に依存
- 関数/ファイルが複雑すぎる
- 命名が不明確
- TODO/FIXME の放置（Issue番号付きは許容）
- 理由なしの `@ts-ignore`、`eslint-disable`

### APPROVE（承認）

全ての REJECT 基準をクリアし、品質基準を満たしている場合に承認する。「条件付き承認」はしない。問題があれば差し戻す。

## ファクトチェック

指摘する前に必ず事実を確認する。

| やるべきこと | やってはいけないこと |
|-------------|-------------------|
| ファイルを開いて実コードを確認 | 「修正済みのはず」と思い込む |
| grep で呼び出し元・使用箇所を検索 | 記憶に基づいて指摘する |
| 型定義・スキーマを突合 | 推測でデッドコードと判断する |
| 生成ファイル（レポート等）とソースを区別 | 生成ファイルをソースコードとしてレビュー |

## 具体的な指摘の書き方

全ての指摘には以下を含める。

- **どのファイルの何行目か**
- **何が問題か**
- **どう修正すべきか**

```
❌ 「構造を見直してください」
❌ 「もう少し整理してください」
❌ 「リファクタリングが必要です」

✅ 「src/auth/service.ts:45 — validateUser() が3箇所で重複。
     共通関数に抽出してください」
```

## 指摘ID管理（finding_id）

同じ指摘の堂々巡りを防ぐため、指摘をIDで追跡する。

- REJECT時に挙げる各問題には `finding_id` を必須で付ける
- 同じ問題を再指摘する場合は、同じ `finding_id` を再利用する
- 再指摘時は状態を `persists` とし、未解決である根拠（ファイル/行）を必ず示す
- 新規指摘は状態 `new` とする
- 解消済みは状態 `resolved` として一覧化する
- `finding_id` のない指摘は無効（判定根拠として扱わない）
- REJECTは `new` または `persists` の問題が1件以上ある場合のみ許可する

## 再オープン条件（resolved → open）

解消済み指摘を再オープンする場合は、再現可能な根拠を必須とする。

- 前回 `resolved` の指摘を再オープンする場合、以下3点を必須で提示する  
  1. 再現手順（コマンド/入力）  
  2. 期待結果と実結果  
  3. 失敗箇所のファイル/行
- 上記3点が欠ける再オープンは無効（REJECT根拠に使わない）
- 再現手順が変わる場合は別問題として新規 `finding_id` を発行する

## finding_id の意味固定

同じ ID に別問題を混在させない。

- 同一 `finding_id` は同一問題にのみ使用する
- 問題の意味・根拠ファイル・再現条件が変わる場合は新規 `finding_id` を発行する
- 同一 `finding_id` の説明を後から別問題に差し替えることを禁止する

## テストファイルの扱い

テストファイルの長さや重複は、原則として保守性の警告として扱う。

- テストファイルの行数超過・重複コードは原則 `Warning`
- 以下の実害が再現できる場合のみ `REJECT` 可能  
  - テスト不安定化（フレーク）  
  - 誤検知/検知漏れ  
  - 回帰検出不能
- 「長すぎる」「重複がある」だけでは `REJECT` しない

## ボーイスカウトルール

来たときよりも美しく。

### 対象

- 変更したファイル内の既存の問題（未使用コード、不適切な命名、壊れた抽象化）
- 変更したモジュール内の構造的な問題（責務の混在、不要な依存）

### 対象外

- 変更していないファイル（既存問題として記録のみ）
- タスクスコープを大きく逸脱するリファクタリング（提案として記載、非ブロッキング）

### 判定

| 状況 | 判定 |
|------|------|
| 変更ファイル内に明らかな問題がある | REJECT — 一緒に修正させる |
| 冗長な式（同値の短い書き方がある） | REJECT |
| 不要な分岐・条件（到達しない、または常に同じ結果） | REJECT |
| 数秒〜数分で修正可能な問題 | REJECT（「非ブロッキング」にしない） |
| 変更の結果として未使用になったコード（引数・import等） | REJECT — 変更起因であり「既存問題」ではない |
| 修正にリファクタリングが必要（スコープが大きい） | 記録のみ（技術的負債） |

既存コードの踏襲を理由にした問題の放置は認めない。既存コードが悪い場合、それに合わせるのではなく改善する。

## 判定ルール

- 変更対象ファイル内で検出した問題は、既存コードであっても全てブロッキング（REJECT対象）として扱う
- 「既存問題」「非ブロッキング」に分類してよいのは、変更対象外のファイルの問題のみ
- 「コード自体は以前から存在していた」は非ブロッキングの理由にならない。変更ファイル内にある以上、ボーイスカウトルールが適用される
- 問題が1件でもあればREJECT。「APPROVE + 警告」「APPROVE + 提案」は禁止

## 堂々巡りの検出

同じ種類の指摘が繰り返されている場合、修正指示の繰り返しではなくアプローチ自体を見直す。

### 同じ問題が繰り返されたら

1. 同じ種類の問題が繰り返されていないか確認
2. 繰り返されている場合、細かい修正指示ではなくアプローチ自体の代替案を提示
3. REJECT する場合でも、「別のアプローチを検討すべき」という観点を含める

「もう一度修正して」と繰り返すより、立ち止まって別の道を示す。


---

# AI Antipattern 検出基準

## 仮定の検証

AIはしばしば仮定を行う。それを検証する。

| 確認項目 | 質問 |
|---------|------|
| 要件 | 実装は実際に要求されたものと一致しているか? |
| コンテキスト | 既存のコードベースの規則に合っているか? |
| ドメイン | ビジネスルールは正しく理解されているか? |
| エッジケース | AIは現実的なエッジケースを考慮したか? |

危険信号:
- 実装が異なる質問に答えているように見える
- コードベースの他の場所にないパターンを使用
- 特定の問題に対して過度に汎用的な解決策

## もっともらしいが間違っている検出

AIは正しく見えるが間違っているコードを生成する。

| パターン | 例 |
|---------|-----|
| 構文は正しいが意味が間違っている | 形式をチェックするがビジネスルールを見落とすバリデーション |
| 幻覚API | 使用しているライブラリバージョンに存在しないメソッドの呼び出し |
| 古いパターン | 学習データからの非推奨アプローチの使用 |
| 過剰エンジニアリング | タスクに不要な抽象化レイヤーの追加 |
| 過小エンジニアリング | 現実的なシナリオのエラーハンドリングの欠如 |
| 配線忘れ | 機構は実装されているが、エントリポイントから渡されていない |

検証アプローチ:
1. このコードは実際にコンパイル/実行できるか?
2. インポートされたモジュール/関数は存在するか?
3. このライブラリバージョンでAPIは正しく使用されているか?
4. 新しいパラメータ/フィールドが追加された場合、呼び出し元から実際に渡されているか?
   - AIは個々のファイル内では正しく実装するが、ファイル横断の結合を忘れがち
   - `options.xxx ?? fallback` で常にフォールバックが使われていないか grep で確認

## コピペパターン検出

AIは同じパターンを、間違いも含めて繰り返すことが多い。

| 確認項目 | アクション |
|---------|----------|
| 繰り返される危険なパターン | 複数の場所で同じ脆弱性 |
| 一貫性のない実装 | ファイル間で異なる方法で実装された同じロジック |
| ボイラープレートの爆発 | 抽象化できる不要な繰り返し |

## コンテキスト適合性評価

コードはこの特定のプロジェクトに合っているか?

| 側面 | 検証 |
|------|------|
| 命名規則 | 既存のコードベースのスタイルに一致 |
| エラーハンドリングスタイル | プロジェクトのパターンと一貫性 |
| ログ出力アプローチ | プロジェクトのログ規則を使用 |
| テストスタイル | 既存のテストパターンに一致 |

確認すべき質問:
- このコードベースに精通した開発者ならこう書くか?
- ここに属しているように感じるか?
- プロジェクト規則からの説明のない逸脱はないか?

## インテグレーションパターンの一貫性

同じ種類のAPI接続（REST呼び出し等）がプロジェクト内で異なる方式で実装されていないか確認する。

| パターン | 例 | 判定 |
|---------|-----|------|
| 生成クライアントと手書きクライアントの混在 | A画面はOrval生成フック、B画面はaxiosInstance直接 | REJECT |
| 同じデータ取得パターンの異なる実装 | A画面はuseQuery+axios、B画面は生成フック | REJECT |
| データ型の定義方式の混在 | A画面は生成された型、B画面は手書きの型 | REJECT |

検証アプローチ:
1. 変更差分のAPI呼び出し方式を確認
2. 同じ目的の既存コードがどの方式で書かれているか grep で確認
3. プロジェクトにAPI生成設定（orval.config.ts等）があるか確認
4. 不整合がある場合、プロジェクトの標準パターンへの統一を指摘する

## スコープクリープ検出

AIは過剰に提供する傾向がある。不要な追加をチェック。

| 確認項目 | 問題 |
|---------|------|
| 追加機能 | 要求されていない機能 |
| 早すぎる抽象化 | 単一実装のためのインターフェース/抽象化 |
| 過剰設定 | 設定可能にする必要のないものを設定可能に |
| ゴールドプレーティング | 求められていない「あると良い」追加 |
| 不要なLegacy対応 | 明示的な指示がないのに旧値のマッピング・正規化ロジックを追加 |

最良のコードは、問題を解決する最小限のコード。

Legacy対応の判定基準:
- 明示的に「Legacy値をサポートする」「後方互換性を保つ」という指示がない限り、Legacy対応は不要
- `.transform()` による正規化、`LEGACY_*_MAP` のようなマッピング、`@deprecated` な型定義は追加しない
- 新しい値のみをサポートし、シンプルに保つ

## デッドコード検出

AIは新しいコードを追加するが、不要になったコードの削除を忘れることが多い。

| パターン | 例 |
|---------|-----|
| 未使用の関数・メソッド | リファクタリング後に残った旧実装 |
| 未使用の変数・定数 | 条件変更で不要になった定義 |
| 到達不能コード | 早期returnの後に残った処理、常に真/偽になる条件分岐 |
| 論理的に到達不能な防御コード | 呼び出し元の制約で絶対に通らない分岐 |
| 未使用のインポート・依存 | 削除された機能のimport文やパッケージ依存 |
| 孤立したエクスポート・公開API | 実体が消えたのにre-exportやindex登録が残っている |
| 未使用のインターフェース・型定義 | 実装側が変更されたのに残った古い型 |
| 無効化されたコード | コメントアウトされたまま放置されたコード |

論理的デッドコードの検出:

AIは「念のため」の防御コードを追加しがちだが、呼び出し元の制約を考慮すると到達不能な場合がある。構文的には到達可能でも、呼び出しチェーンの前提条件により論理的に到達しないコードは削除する。

```typescript
// REJECT - 呼び出し元がTTY必須のインタラクティブメニュー経由のみ
// TTYがない環境からこの関数が呼ばれることはない
function showFullDiff(cwd: string, branch: string): void {
  const usePager = process.stdin.isTTY === true;
  // usePager は常に true（呼び出し元がTTYを前提としている）
  const pager = usePager ? 'less -R' : 'cat';  // else節は到達不能
}

// OK - 呼び出し元の制約を理解し、不要な分岐を排除
function showFullDiff(cwd: string, branch: string): void {
  // インタラクティブメニューからのみ呼ばれるためTTYは常に存在する
  spawnSync('git', ['diff', ...], { env: { GIT_PAGER: 'less -R' } });
}
```

検証アプローチ:
1. 防御的な分岐を見つけたら、grep でその関数の全呼び出し元を確認
2. 全呼び出し元が既にその条件を満たしている場合、防御は不要
3. 変更・削除されたコードを参照している箇所がないか grep で確認
4. 公開モジュール（index ファイル等）のエクスポート一覧と実体が一致しているか確認
5. 新規追加されたコードに対応する古いコードが残っていないか確認

## フォールバック・デフォルト引数の濫用検出

AIは不確実性を隠すためにフォールバックやデフォルト引数を多用する。

| パターン | 例 | 判定 |
|---------|-----|------|
| 必須データへのフォールバック | `user?.id ?? 'unknown'` | REJECT |
| デフォルト引数の濫用 | `function f(x = 'default')` で全呼び出し元が省略 | REJECT |
| null合体で渡す口がない | `options?.cwd ?? process.cwd()` で上位から渡す経路なし | REJECT |
| try-catch で空値返却 | `catch { return ''; }` | REJECT |
| 多段フォールバック | `a ?? b ?? c ?? d` | REJECT |
| 条件分岐でサイレント無視 | `if (!x) return;` で本来エラーをスキップ | REJECT |

検証アプローチ:
1. 変更差分で `??`、`||`、`= defaultValue`、`catch` を grep
2. 各フォールバック・デフォルト引数について:
   - 必須データか? → REJECT
   - 全呼び出し元が省略しているか? → REJECT
   - 上位から値を渡す経路があるか? → なければ REJECT
3. 理由なしのフォールバック・デフォルト引数が1つでもあれば REJECT

## 未使用コードの検出

AIは「将来の拡張性」「対称性」「念のため」で不要なコードを生成しがちである。現時点で呼ばれていないコードは削除する。

| 判定 | 基準 |
|------|------|
| REJECT | 現在どこからも呼ばれていないpublic関数・メソッド |
| REJECT | 「対称性のため」に作られたが使われていないsetter/getter |
| REJECT | 将来の拡張のために用意されたインターフェースやオプション |
| REJECT | exportされているが、grep で使用箇所が見つからない |
| OK | フレームワークが暗黙的に呼び出す（ライフサイクルフック等） |

検証アプローチ:
1. 変更・削除されたコードを参照している箇所がないか grep で確認
2. 公開モジュール（index ファイル等）のエクスポート一覧と実体が一致しているか確認
3. 新規追加されたコードに対応する古いコードが残っていないか確認

## 不要な後方互換コードの検出

AIは「後方互換のために」不要なコードを残しがちである。これを見逃さない。

削除すべき後方互換コード:

| パターン | 例 | 判定 |
|---------|-----|------|
| deprecated + 使用箇所なし | `@deprecated` アノテーション付きで誰も使っていない | 即削除 |
| 新APIと旧API両方存在 | 新関数があるのに旧関数も残っている | 両方に使用箇所がある場合を除き、旧を削除 |
| 移行済みのラッパー | 互換のために作ったが移行完了済み | 削除 |
| コメントで「将来削除」 | `// TODO: remove after migration` が放置 | 今すぐ削除 |
| Proxy/アダプタの過剰使用 | 後方互換のためだけに複雑化 | シンプルに置換 |

残すべき後方互換コード:

| パターン | 例 | 判定 |
|---------|-----|------|
| 外部公開API | npm パッケージのエクスポート | 慎重に検討 |
| 設定ファイル互換 | 旧形式の設定を読める | メジャーバージョンまで維持 |
| データ移行中 | DBスキーマ移行の途中 | 移行完了まで維持 |

判断基準:
1. 使用箇所があるか? → grep/検索で確認。なければ削除
2. 新旧両方に使用箇所があるか? → 両方が現在使われているなら、後方互換ではなく並存設計の可能性がある。呼び出し元を確認
3. 外部に公開しているか? → 内部のみなら即削除可能
4. 移行は完了したか? → 完了なら削除

AIが「後方互換のため」と言ったら疑う。本当に必要か確認せよ。

## 決定トレーサビリティレビュー

Coderの決定ログが妥当か検証する。

| 確認項目 | 質問 |
|---------|------|
| 決定が文書化されている | 自明でない選択は説明されているか? |
| 理由が妥当 | 理由は理にかなっているか? |
| 代替案が検討されている | 他のアプローチは評価されたか? |
| 仮定が明示されている | 仮定は明示的で合理的か? |
