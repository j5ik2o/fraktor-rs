use alloc::{string::ToString, vec, vec::Vec};

use cellactor_utils_core_rs::sync::{ArcShared, NoStdMutex};

use super::ActorCell;
use crate::{
  actor_prim::{Actor, ActorContextGeneric, Pid},
  error::ActorError,
  mailbox::ScheduleHints,
  messaging::{AnyMessage, AnyMessageView, SystemMessage, message_invoker::MessageInvoker},
  props::Props,
  system::SystemState,
};

struct ProbeActor;

impl Actor for ProbeActor {
  fn receive(
    &mut self,
    _ctx: &mut ActorContextGeneric<'_, crate::NoStdToolbox>,
    _message: AnyMessageView<'_, crate::NoStdToolbox>,
  ) -> Result<(), ActorError> {
    Ok(())
  }
}

struct RecordingActor {
  log: ArcShared<NoStdMutex<Vec<Pid>>>,
}

impl RecordingActor {
  fn new(log: ArcShared<NoStdMutex<Vec<Pid>>>) -> Self {
    Self { log }
  }
}

struct LifecycleRecorderActor {
  log: ArcShared<NoStdMutex<Vec<&'static str>>>,
}

impl LifecycleRecorderActor {
  fn new(log: ArcShared<NoStdMutex<Vec<&'static str>>>) -> Self {
    Self { log }
  }
}

impl Actor for LifecycleRecorderActor {
  fn pre_start(&mut self, _ctx: &mut ActorContextGeneric<'_, crate::NoStdToolbox>) -> Result<(), ActorError> {
    self.log.lock().push("pre_start");
    Ok(())
  }

  fn receive(
    &mut self,
    _ctx: &mut ActorContextGeneric<'_, crate::NoStdToolbox>,
    _message: AnyMessageView<'_, crate::NoStdToolbox>,
  ) -> Result<(), ActorError> {
    self.log.lock().push("receive");
    Ok(())
  }

  fn post_stop(&mut self, _ctx: &mut ActorContextGeneric<'_, crate::NoStdToolbox>) -> Result<(), ActorError> {
    self.log.lock().push("post_stop");
    Ok(())
  }
}

impl Actor for RecordingActor {
  fn receive(
    &mut self,
    _ctx: &mut ActorContextGeneric<'_, crate::NoStdToolbox>,
    _message: AnyMessageView<'_, crate::NoStdToolbox>,
  ) -> Result<(), ActorError> {
    Ok(())
  }

  fn on_terminated(
    &mut self,
    _ctx: &mut ActorContextGeneric<'_, crate::NoStdToolbox>,
    pid: Pid,
  ) -> Result<(), ActorError> {
    self.log.lock().push(pid);
    Ok(())
  }
}

#[test]
fn actor_cell_holds_components() {
  let system = ArcShared::new(SystemState::new());
  let props = Props::from_fn(|| ProbeActor);
  let cell = ActorCell::create(system, Pid::new(1, 0), None, "worker".to_string(), &props.expect("create actor cell");

  assert_eq!(cell.pid(), Pid::new(1, 0));
  assert_eq!(cell.name(), "worker");
  assert!(cell.parent().is_none());
  assert_eq!(cell.mailbox().system_len(), 0);
  assert_eq!(cell.dispatcher().mailbox().system_len(), 0);
}

#[test]
fn handle_watch_is_idempotent() {
  let system = ArcShared::new(SystemState::new());
  let props = Props::from_fn(|| ProbeActor);
  let target = ActorCell::create(system.clone(), Pid::new(10, 0), None, "target".to_string(), &props.expect("create actor cell");
  system.register_cell(target.clone());

  target.handle_watch(Pid::new(20, 0));
  target.handle_watch(Pid::new(20, 0));

  assert_eq!(target.watchers.lock().len(), 1);
}

#[test]
fn handle_unwatch_removes_pid() {
  let system = ArcShared::new(SystemState::new());
  let props = Props::from_fn(|| ProbeActor);
  let target = ActorCell::create(system.clone(), Pid::new(11, 0), None, "target".to_string(), &props.expect("create actor cell");
  system.register_cell(target.clone());

  target.handle_watch(Pid::new(21, 0));
  target.handle_unwatch(Pid::new(21, 0));

  assert_eq!(target.watchers.lock().len(), 0);
}

#[test]
fn notify_watchers_sends_terminated() {
  let state = ArcShared::new(SystemState::new());
  let props = Props::from_fn(|| ProbeActor);
  let target = ActorCell::create(state.clone(), Pid::new(30, 0), None, "target".to_string(), &props.expect("create actor cell");
  let log = ArcShared::new(NoStdMutex::new(Vec::new()));
  let watcher_props = Props::from_fn({
    let log = log.clone();
    move || RecordingActor::new(log.clone())
  });
  let watcher = ActorCell::create(state.clone(), Pid::new(31, 0), None, "watcher".to_string(), &watcher_props.expect("create actor cell");
  state.register_cell(target.clone());
  state.register_cell(watcher.clone());

  target.handle_watch(watcher.pid());
  target.notify_watchers_on_stop();
  assert_eq!(log.lock().clone(), vec![target.pid()]);
  assert_eq!(target.watchers.lock().len(), 0);
}

#[test]
fn drop_adapter_refs_marks_lifecycle_stopped() {
  let system = ArcShared::new(SystemState::new());
  let props = Props::from_fn(|| ProbeActor);
  let cell = ActorCell::create(system.clone(), Pid::new(50, 0), None, "adapter".to_string(), &props.expect("create actor cell");
  system.register_cell(cell.clone());

  let (_id, lifecycle) = cell.acquire_adapter_handle();
  assert!(lifecycle.is_alive());

  cell.drop_adapter_refs();
  assert!(!lifecycle.is_alive());
}

#[test]
fn remove_adapter_handle_stops_single_handle() {
  let system = ArcShared::new(SystemState::new());
  let props = Props::from_fn(|| ProbeActor);
  let cell = ActorCell::create(system.clone(), Pid::new(51, 0), None, "adapter".to_string(), &props.expect("create actor cell");
  system.register_cell(cell.clone());

  let (id, lifecycle) = cell.acquire_adapter_handle();
  assert!(lifecycle.is_alive());

  cell.remove_adapter_handle(id);
  assert!(!lifecycle.is_alive());
}

#[test]
fn create_system_message_runs_pre_start() {
  let state = ArcShared::new(SystemState::new());
  let log = ArcShared::new(NoStdMutex::new(Vec::new()));
  let props = Props::from_fn({
    let log = log.clone();
    move || LifecycleRecorderActor::new(log.clone())
  });
  let cell = ActorCell::create(state.clone(), Pid::new(40, 0), None, "probe".to_string(), &props.expect("create actor cell");
  state.register_cell(cell.clone());

  MessageInvoker::invoke_system_message(&*cell, SystemMessage::Create).expect("create");

  let snapshot = log.lock().clone();
  assert_eq!(snapshot, vec!["pre_start"]);
}

#[test]
fn recreate_system_message_invokes_post_stop_then_pre_start() {
  let state = ArcShared::new(SystemState::new());
  let log = ArcShared::new(NoStdMutex::new(Vec::new()));
  let props = Props::from_fn({
    let log = log.clone();
    move || LifecycleRecorderActor::new(log.clone())
  });
  let cell = ActorCell::create(state.clone(), Pid::new(41, 0), None, "probe".to_string(), &props.expect("create actor cell");
  state.register_cell(cell.clone());

  MessageInvoker::invoke_system_message(&*cell, SystemMessage::Create).expect("create");
  MessageInvoker::invoke_system_message(&*cell, SystemMessage::Recreate).expect("recreate");

  let snapshot = log.lock().clone();
  assert_eq!(snapshot, vec!["pre_start", "post_stop", "pre_start"]);
}

#[test]
fn system_queue_is_drained_before_user_queue() {
  let state = ArcShared::new(SystemState::new());
  let log = ArcShared::new(NoStdMutex::new(Vec::new()));
  let props = Props::from_fn({
    let log = log.clone();
    move || LifecycleRecorderActor::new(log.clone())
  });
  let cell = ActorCell::create(state.clone(), Pid::new(42, 0), None, "probe".to_string(), &props.expect("create actor cell");
  state.register_cell(cell.clone());

  cell.dispatcher().enqueue_system(SystemMessage::Create).expect("system enqueue");
  cell.actor_ref().tell(AnyMessage::new(())).expect("user enqueue");

  cell.dispatcher().register_for_execution(ScheduleHints {
    has_system_messages: true,
    has_user_messages:   true,
    backpressure_active: false,
  });

  let snapshot = log.lock().clone();
  assert_eq!(snapshot, vec!["pre_start", "receive"]);
}
